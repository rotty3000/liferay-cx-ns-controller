## A Controller that manages Client Extension Namespaces from DXP Virtual Instance ConfigMaps

When the Liferay DXP Kubernetes Agent is enabled, for every Virtual Instance defined in DXP, it emits and maintains a ConfigMap that describe the Virtual Instance. When Virtual Instances are created a new ConfigMap is added. When a Virtual Instance is deleted the ConfigMap is removed and when the Virtual Instance is updated the ConfigMap is updated.

The controller should ensure the existence of at least one Namespace for each Virtual Instance. The namespace name should be autogenerated to reflect the Virtual Instance's id combined with an application alias (which by default is `cx`). This alias allows multiple Namespaces to be associated with the Virtual Instance. This allows for Marketplace Apps to be isolated into their own Namespace while still being associated to the Virtual Instance.

### Deploy the locally build controller into a K3d cluster

Start by installing a basic Liferay DXP setup:

```bash
# if from source
helm upgrade -i -n liferay-system --create-namespace liferay . \
	--set image.tag=7.4.13.nightly

# if from registry
helm upgrade -i -n liferay-system --create-namespace liferay \
	oci://us-central1-docker.pkg.dev/liferay-artifact-registry/liferay-helm-chart/liferay-default \
	--set image.tag=7.4.13.nightly
```

Watch DXP:

```bash
watch -n .5 kubectl -n liferay-system get statefulset,pod,pvc,svc,ingress,cm,secret -o wide
```

Install the controller:

```bash
# build the image
make docker-build

# tag the image to push it into the k3d registry
docker tag liferay-cx-ns-controller:latest registry:5000/liferay-cx-ns-controller:latest

# push the image into the k3d registry
docker push registry:5000/liferay-cx-ns-controller:latest

# deploy the controller into the k3d cluster (the namespace is determined by `config/default/kustomization.yaml` which is `liferay-cx-ns-controller-system` by default)
make deploy IMG=registry:5000/liferay-cx-ns-controller:latest
```

Watch any namespaces managed by the controller:

```bash
watch -n .5 kubectl get ns --selector "app.kubernetes.io/managed-by=liferay-cx-ns-controller"
```

Watch any DXP metadata configmaps sync into those namespaces by the controller:

```bash
watch -n .5 kubectl get -A cm --selector "cx.liferay.com/synced-from-configmap"
```

Create the ingress to reach Liferay DXP:

```bash
kubectl -n liferay-system create ingress liferay --rule="*.dxp.docker.localhost/*=liferay-default:http"
```

Login to Liferay DXP (`test@liferay.com/test`) and create a Virtual Instance:

```bash
open http://main.dxp.docker.localhost
```

Watch as the controller creates the managed default namespace for the VI and syncs the DXP metadata ConfigMap into it.
